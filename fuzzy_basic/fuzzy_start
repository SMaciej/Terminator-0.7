#include <Fuzzy.h>
#include <FuzzyComposition.h>
#include <FuzzyInput.h>
#include <FuzzyIO.h>
#include <FuzzyOutput.h>
#include <FuzzyRule.h>
#include <FuzzyRuleAntecedent.h>
#include <FuzzyRuleConsequent.h>
#include <FuzzySet.h>

//#include<SoftwareSerial.h>
//SoftwareSerial BT(1, 0);

// motor one
int enA = 9;
int in1 = 10;
int in2 = 11;
// motor two
int enB = 5;
int in3 = 6;
int in4 = 7;
// IR sensors
int leftIR = 13;
int rightIR = 12;
// ultrasonic sensors
int middleEyeTrigger = 8;
int middleEye = 4;
int leftEyeTrigger = 3;
int leftEye = 2;
int rightEye = 15;
int rightEyeTrigger = 16;
// bluetooth signal
char bt_signal;
char btx;
Fuzzy* fuzzy = new Fuzzy();
int test = 0;


void setup() {
  // set all the control pins to outputs
  pinMode(enA, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  pinMode(middleEye,OUTPUT);
  pinMode(leftEye,OUTPUT);
  pinMode(rightEye,OUTPUT);
  // set serial
  Serial.begin(9600);
  // set bluetooth serial
  //BT.begin(9600);
  //BT.println("Terminator 0.7 connected.");
  

  // ZBIORY ROZMYTE
  
  //Odleglosc na sensorze srodkowym
  FuzzyInput* distance = new FuzzyInput(1);
  //
  FuzzySet* big = new FuzzySet(15,30,30,30);
  distance->addFuzzySet(big);
  FuzzySet* average = new FuzzySet(0,15,15,30);
  distance->addFuzzySet(average);
  FuzzySet* small = new FuzzySet(0,0,0,15);
  distance->addFuzzySet(small);
  //
  fuzzy->addFuzzyInput(distance);

  //Odleglosc na sensorze lewym
  FuzzyInput* distance2 = new FuzzyInput(2);
  //
  FuzzySet* big2 = new FuzzySet(15,30,30,30);
  distance2->addFuzzySet(big2);
  FuzzySet* average2 = new FuzzySet(0,15,15,30);
  distance2->addFuzzySet(average2);
  FuzzySet* small2 = new FuzzySet(0,0,0,15);
  distance2->addFuzzySet(small2);
  //
  fuzzy->addFuzzyInput(distance2);
  
  // Predkosc
  FuzzyOutput* speed = new FuzzyOutput(1);
  //
  FuzzySet* slow = new FuzzySet(70,120,120,120);
  speed->addFuzzySet(slow);
  FuzzySet* mild = new FuzzySet(100,125,125,150);
  speed->addFuzzySet(mild);
  FuzzySet* fast = new FuzzySet(125,230,230,230);
  speed->addFuzzySet(fast);
  //
  fuzzy->addFuzzyOutput(speed);

  // Obrot (jak duzy powinien byc, tzn czas trwania)
  FuzzyOutput* turn = new FuzzyOutput(2);
  //
  FuzzySet* small_turn = new FuzzySet(300,600,600,600);
  turn->addFuzzySet(small_turn);
  FuzzySet* mild_turn = new FuzzySet(300,500,500,1100);
  turn->addFuzzySet(mild_turn);
  FuzzySet* fast_turn = new FuzzySet(500,1500,1500,1500);
  turn->addFuzzySet(fast_turn);
  //
  fuzzy->addFuzzyOutput(turn);

  // ZASADY LOGIKI ROZMYTEJ
  // Zasada pierwsza
  
  FuzzyRuleAntecedent* middleSmallAndLeftSmall = new FuzzyRuleAntecedent();
  middleSmallAndLeftSmall->joinWithAND(small,small2);
  FuzzyRuleConsequent* DoATurn= new FuzzyRuleConsequent();
  DoATurn->addOutput(small_turn);
  //
  FuzzyRule* fuzzyRule01 = new FuzzyRule(1, middleSmallAndLeftSmall, DoATurn);
  fuzzy->addFuzzyRule(fuzzyRule01);
  
  // Zasada druga
  
  FuzzyRuleAntecedent* middleBigAndLeftBig = new FuzzyRuleAntecedent();
  middleBigAndLeftBig->joinWithAND(big,big2);
  FuzzyRuleConsequent* GoForwardFast= new FuzzyRuleConsequent();
  GoForwardFast->addOutput(fast);
  //
  FuzzyRule* fuzzyRule02 = new FuzzyRule(1, middleBigAndLeftBig, GoForwardFast);
  fuzzy->addFuzzyRule(fuzzyRule02);

  // Zasada trzecia

  FuzzyRuleAntecedent* middleMediumAndLeftMedium = new FuzzyRuleAntecedent();
  middleMediumAndLeftMedium->joinWithAND(average,average2);
  FuzzyRuleConsequent* GoMediumFast= new FuzzyRuleConsequent();
  GoMediumFast->addOutput(mild);
  //
  FuzzyRule* fuzzyRule03 = new FuzzyRule(1, middleMediumAndLeftMedium, GoMediumFast);
  fuzzy->addFuzzyRule(fuzzyRule03);
  
/*
  // Zasada Druga
  FuzzyRuleAntecedent* ifSensorDuno = new FuzzyRuleAntecedent();
  ifSensorDuno->joinSingle(duno);
  FuzzyRuleConsequent* thenSpeedMild = new FuzzyRuleConsequent();
  thenSpeedMild->addOutput(mild);

  FuzzyRule* fuzzyRule02 = new FuzzyRule(1, ifSensorDuno, thenSpeedMild);
  fuzzy->addFuzzyRule(fuzzyRule02);

  // Zasada Trzecia
  FuzzyRuleAntecedent* ifSensorDang = new FuzzyRuleAntecedent();
  ifSensorDang->joinSingle(dang);
  FuzzyRuleConsequent* thenSpeedSlow = new FuzzyRuleConsequent();
  thenSpeedSlow->addOutput(slow);

  FuzzyRule* fuzzyRule03 = new FuzzyRule(1, ifSensorDang, thenSpeedSlow);
  fuzzy->addFuzzyRule(fuzzyRule03);  
*/
}

void motorsOff() {
  // turn all the motors off
  digitalWrite(in1, LOW);
  digitalWrite(in2, LOW);   
  digitalWrite(in3, LOW);
  digitalWrite(in4, LOW); 
}
  

void motorsForward(int period, int power) {
  // run all the motors in a forward direction
  
  // turn on motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, HIGH);
  digitalWrite(in3, LOW);
  digitalWrite(in4, HIGH);
  
  // set motors speed
  analogWrite(enA, power);
  analogWrite(enB, power);
  
  if (period != 0) { 
    delay(period);    
  }
  
  motorsOff();
}

void motorsBackward(int period, int power) {
  // run all the motors in a backward direction
  
  // turn on motors
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  
  // set motors speed
  analogWrite(enA, power);
  analogWrite(enB, power);
  
  delay(period);
  
  motorsOff();
}

void motorsTurnRight(int period, int power) {
  // run the left motors only
  
  // turn on motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, HIGH);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);

  // set motors speed
  analogWrite(enA, power);
  analogWrite(enB, power);
  
  delay(period);
  
  motorsOff();
}

void motorsTurnLeft(int period, int power) {
  // run the right motors only
  
  // turn on motors
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  digitalWrite(in3, LOW);
  digitalWrite(in4, HIGH);
  
  // set motors speed
  analogWrite(enA, power);
  analogWrite(enB, power);
  
  delay(period);
  
  motorsOff();
}

int IRleft() {
  return digitalRead(leftIR);
}

int IRright() {
  return digitalRead(rightIR);
}
/*
void line_tracking() {
  if(IRleft() == 1 && IRright() == 1) {
    motorsForward(10,85);
  }
  if(IRleft() == 0 && IRright() == 1) {
    motorsTurnRight(10,130);
  }
  if(IRleft() == 1 && IRright() == 0) {
    motorsTurnLeft(10,130);
  }
  if(IRleft() == 0 && IRright() == 0) {
    motorsForward(10,85);
  }
}
*/
/*
void listen_bluetooth() {
  if (BT.available()) {
    bt_signal = (BT.read());
    if (bt_signal == '0') {
      motorsOff();
    }
    while (bt_signal == 'F') {
      // drive forward
      btx = (BT.read());
      motorsForward(0, 140);
      if (btx == '0') {
        break;
      }
    }
    if (bt_signal == 'B') {
      // drive backward
      motorsBackward(1000, 140);
    }
    if (bt_signal == 'L') {
      // turn left
      motorsTurnLeft(500, 140);
    } 
    if (bt_signal == 'R') {
      // turn right
      motorsTurnRight(500, 140);
    }
    while (bt_signal == 'T') {
      // line-tracking
      btx = (BT.read());
      line_tracking();
      if (btx == '0') {
        break;
      }
    }
    if (bt_signal == 'S') {
      // line-tracking
      ultrasonic_values();
    }
  }
}
*/

unsigned long ping(int ultraSoundSignal) {
  unsigned long echo = 0;
  unsigned long ultrasoundValue = 0;
  pinMode(ultraSoundSignal, OUTPUT); // Switch signalpin to output
  digitalWrite(ultraSoundSignal, LOW); // Send low pulse
  delayMicroseconds(2); // Wait for 2 microseconds
  digitalWrite(ultraSoundSignal, HIGH); // Send high pulse
  delayMicroseconds(5); // Wait for 5 microseconds
  digitalWrite(ultraSoundSignal, LOW); // Holdoff
  pinMode(ultraSoundSignal, INPUT); // Switch signalpin to input
  digitalWrite(ultraSoundSignal, HIGH); // Turn on pullup resistor
  // please note that pulseIn has a 1sec timeout, which may
  // not be desirable. Depending on your sensor specs, you
  // can likely bound the time like this -- marcmerlin
  // echo = pulseIn(ultraSoundSignal, HIGH, 38000)
  echo = pulseIn(ultraSoundSignal, HIGH); //Listen for echo
  ultrasoundValue = (echo / 58.138); //convert to CM then to inches
  return ultrasoundValue;
}

/*
void ultrasonic_values() {
   int x = 0;
   int y = 0;
/delay(   int z = 0;
   y = ping(middleEye);
   x = ping(leftEye);
   z = ping(rightEye);
   //Serial.println(x);
   //Serial.println(y);
   // Dziala lewe (x) i srodkowe (x) oko
   /200); //delay 1/4 seconds.
}
*/

int sonic_left() {
   int x = 0;
   x = ping(leftEye);
   if(x>=30)
   {
    x = 30;
   }
   return x;
}

int sonic_middle() {
   int y= 0;
   y = ping(middleEye);
   if(y>=30)
   {
    y = 30;
   }
   return y;
}
/*
double average_ping(int ultraSoundSignal) {
  unsigned long sum;
 
  for (int i=0; i<=9; i++) {
    sum += ping(ultraSoundSignal);
    delay(100);
  }
 
  return sum/10;
}
*/

void loop() {
  //listen_bluetooth();
  //motorsForward(1000,195);
 // Serial.println(average_ping(middleEye));
  Serial.println(sonic_middle());
  Serial.println(sonic_left());
  //Serial.println(average_ping(leftEye));

  
  Serial.println(test);
  
  fuzzy->setInput(1, test); // middle
  fuzzy->setInput(2, test); // left
  fuzzy->fuzzify();

  if(test >= 30)
  {
    test = 0;
  }
  else
  {
    test = test + 5;
  }
  
  
  int output = 0;
  output = fuzzy->defuzzify(1);
  int output2 = 0;
  output2 = fuzzy->defuzzify(2);

  
  
  Serial.println(output);
  Serial.println(output2);
  //output = 125;
  //motorsForward(300,output);
  
  if(output2 < 300)
  {
  //  Serial.println(sonic_middle());
  //  Serial.println(sonic_left());
  //  Serial.println(output);
    //output = 125;
    motorsForward(300,output);
    Serial.println("Wykonalem jazde do przodu o mocy");
    Serial.println(output);
  }
  if(output2 < 600 && output2 > 300)
  {
  //  Serial.println(sonic_middle());
   // Serial.println(sonic_left());
 //   Serial.println(output2);
    motorsTurnLeft(output2,output);
    Serial.println("wykonalem skret w lewo");
  }

  delay(1000);
  

  /*
  motorsTurnLeft(550,125);
  delay(1000);
  // obr√≥t o 180
  motorsTurnLeft(1100,125);

  */
 // Serial.println(output);
  
}
